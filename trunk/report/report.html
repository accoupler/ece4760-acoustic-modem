<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">	
<head>
	<title>ECE 4760 Final Project: Acoustic Modem</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Language" content="en-us" />
	<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
	<link rel="stylesheet" type="text/css" media="screen" href="screen.css" />
</head>

<body class="onecolumn">
<div id="skipnav">
	<a href="#content">Skip to main content</a>
</div>

<hr />

<div id="cu-identity">

	<div id="cu-logo">
		<a id="insignia-link" href="http://www.cornell.edu/"><img src="images/unit_signature_unstyled.gif" alt="Cornell University" width="416" height="88" border="0" /></a>
		<div id="unit-signature-links">
			<a id="cornell-link" href="http://www.cornell.edu/">Cornell University</a>
			<a id="unit-link1" href="http://www.ece.cornell.edu/">School of Electrical and Computer Engineering</a>
			<a id="unit-link2" href="http://www.ece.cornell.edu/">School of Electrical and Computer Engineering</a>
		</div>

	</div>
</div>

<div id="header">	
	<div id="navigation">
		<ul>
			<li><a href="#design">High Level Design</a></li>
			<li><a href="#implementation">Implementation</a></li>
			<li><a href="#results">Results</a></li>
			<li><a href="#conclusion">Conclusion</a></li>
			<li><a href="#appendix">Appendix</a></li>				
		</ul>
	</div>
	<hr />
	<div id="identity">
		<h1>Acoustic Data Modem</h1>
		<h4>Greg Malysa (gjm76) and Arseney Romanenko (asr96)</h4>
	</div>
</div>

<hr />

<div id="wrap">

<div id="content">
	<div id="main">
<center><div class="main-photo-large">
	<img src="project_files/modem.jpg" width="510"/>
	<p class="caption">Picture of Acoustic Modem</p>
</div></center>
<div class="bridge-section">
<h2>Introduction</h2>
<p>		
For our final design project, we designed and built a prototype acoustic modem to serve as a physical transport layer for digital communications. 
It converts between a digital communications scheme (RS-232) and an acoustically coupled communications scheme of our own design. Our project 
consists of a pair of such modems to operate as transmit/receive pairs and supports duplex communications. Although our modem operates in air, 
it is a proof-of-concept experiment in encoding, decoding, and data transmission techniques that will be used in the following years by the CUAUV 
team to design a system capable of communicating over some distance underwater.
</p>
<h2 id="design">High Level Design</h2>
<p><a href="#rationale">Rationale</a> | <a href="#math">Background Math</a> | <a href="#tradeoff">Design Tradeoffs</a> | <a href="#standards">Intellectual Property and Standards</a></p>
<h3 id="rationale">Rationale</h3>
<p>
We chose this product because of its relevance to a student project team we were both members of, 
CUAUV (Cornell University Autonomous Underwater Vehicle team). Usually, remote-controlled vehicles use 
radio frequency (RF) wireless communications to transmit data between the device and its operator. 
However, due to the nature of water, electromagnetic waves do not propagate well, with an effective 
range of about a foot, depending on frequency. This makes them unsuitable for communicating with AUVs. 
Acoustic data, however, can propagate very far underwater and acoustic underwater communications is 
currently an important area of research at Woods Hole Oceanographic Institute (WHOI). Inspired by their 
success and the existence of several commercial acoustic modems, our team has as a long term goal the 
creation of an acoustic modem that can be used to communicate with the vehicle while it is in the water 
without a tether. Our project serves as a prototype to help us develop our own algorithms and techniques 
for encoding and processing data acoustically.
</p>

<h3 id="math">Background Math</h3>
<p>
Because we used cheap audio-range speakers and microphones, our project was limiting to transmitting within 
the range of human hearing, ~20 Hz - 20 kHz. Therefore, we selected an encoding scheme that minimized per-byte 
bandwidth utilization while retaining simplicity, so that it was possible to implement decoding. The two most 
intuitive and basic digital encoding schemes are frequency-shift keying, where data is transmitted on a pair of 
frequencies, each representing a distinct digital value, and on-off keying, where the presence or absence of a 
single frequency is used to encode a digital value. We chose the second (OOK) because it requires half the acoustic 
bandwidth (uses only one frequency per channel, rather than two) to transmit a particular amount of data. We 
also chose to use an asynchronous design in order to avoid paying for the overhead of having an additional 
clock frequency, instead breaking the transmissions into a series of known-width pulses. Transmitted data is 
broken into chunks of 64 samples so as to conveniently fit into a power of two size buffer so that it can efficiently 
be implemented as a circular buffer. Each physical frame consists of a start bit (S1, a one bit), eight data bits, 
most-significant-bit first, and a stop bit (S2, a zero bit). At a sampling rate of 40 kHz (chosen to avoid aliasing 
across the entire 20 Hz-20 kHz range), 64 samples corresponds to a pulse width of 1.6 ms, which limits each frequency 
channel to transmitting 62.5 complete frames per second as a theoretical max.
<center><div class="main-photo-large">
	<img src="frame.png" alt="" width="510"/>
	<p class="caption">Sample Transmission Frame</p>
</div></center>
</p><p>
Next, as we are limited by the computational power of our Atemga644 microcontroller, and we would ideally transmit and 
receive from a single microcontroller, we designed a hybrid algorithm for detecting transmitted data using FIR filters 
to estimate the magnitude of specific frequency components over time. For each frequency of interest (which will be 
derived afterwards), we resample at that frequency, exploiting aliasing to obtain a DC component corresponding to the 
amplitude of the frequency. Because the cosine of zero is one, the magnitude of the DC component can be estimated with 
a simple sum of those samples. However, because the real frequency component may have a non-zero phase shift associated 
with it, at DC it will have an analogous "phase shift" which requires that a second resampler to be used with a 90-degree 
phase delay-this pair together can estimate the Fourier Transform evaluated at DC for phase and magnitude information.
<center><div class="main-photo-large">
	<img src="flowchart.png" alt="" width="510"/>
	<p class="caption">Magnitude Estimation Process Flowchart</p>
</div></center>
</p><p>
However, it is important to consider the effects of aliasing on frequencies OTHER than the frequency of interest. Usually, 
aliasing is a bad property to have in a digital system, as it can cause other frequencies to appear as the target frequency. 
For instance, when sampling at 6 kHz, the possible aliases that are within our analog pass-band and appear as a DC signal are 
true DC, 6 kHz, 12 kHz, and 18 kHz. Therefore, in selecting the frequencies for our transmission channels, if we choose 6 
kHz as a transmit frequency, we cannot also use 12 or 18 kHz. Because the Fourier Transform estimator is implemented as a 
moving average, it can also be interpreted as an FIR filter, which has a known frequency response. An N-term moving average 
filter has a frequency response characterized by a maximum at DC and <img src="image004.png" alt="|N/2|" /> zeros evenly spaced around the unit circle. The 
number of terms in the moving average filter for each frequency is chosen by having the length of the filter match the length 
of each burst in time (1.6 ms). Because it is unlikely for these to match precisely, the filters are usually defined to extend 
one sample longer than the burst. In general, therefore, with sampling frequency fs and target frequency f, the length of the 
appropriate averaging filter is <img src="image006.png" alt="N=|64/(fs/f)|" />. For example, for 6 kHz, N is 10. Because the window is so short, it is important 
to minimize the interference between frequency channels, which is most easily done by having each channel match with a zero 
in the moving average for all of the other channels. Due to aliasing between the channels, a particular channel frequency may also 
fall on the alias of a zero rather than the normal interpretation of the location of the zero.
<center><div class="main-photo-large">
	<img src="6000hz.png" alt="" width="510"/>
	<p class="caption">Sample Frequency Response for an 10-term Averager (used for 6 kHz)</p>
</div></center>
</p><p>
Fortunately, it is possible to satisfy the requirement that each transmit frequency alias to a zero of all other transmit frequencies 
for at least four frequencies in the range 20 Hz-20 kHz. Table 1 lists the zeros for the frequencies we have chosen. Aliases of these 
zeros occur for each zero plus a multiple of the sampling frequency (4.8, 6, 8.4, or 10.8 kHz).
<center><div class="main-photo-largest">
	<img src="zero_table.png" alt="" width=630"/>
	<p class="caption">Zeros of N-Term Averagers</p>
</div></center>
</p><p>
Finally, because the dip around each zero in the averager's response is fairly narrow, it is important to avoid spectral leakage. Because 
the data we transmitted is organized into pulses, a window function is implicitly applied to the sine whose frequency we are attempting 
to transmit. In the case of a naive implementation using a simple rectangular window of uniform amplitude, this leads to significant sidelobes
as described <a href="http://en.wikipedia.org/wiki/Window_function#Rectangular_window">on Wikipedia</a>. In an effort to reduce the possibility 
of spectral leakage, we chose to use a Hann window of equal length to our transmission burst. Other windows may have offered better 
mainlobe-to-sidelobe ratios, but we felt that the Hann window was sufficient for our purposes.
</p><p>
As is described in the software implementation section, difficulties arise when using the magnitude of the FIR filter outputs alone, 
which means that naive methods depending on absolute magnitude of a filter's output are insufficient. When processing a single sample 
from the start of a pulse, with any filter it will appear similar to an impulse, which will cause the output to increase regardless 
of what the filter's response is to the true frequency of the wave to which the sample belongs, and the output will not decrease 
appropriately until more samples from the wave are processed. The A/D converters are also limited in resolution (in this case, 8 bits) 
and all filtering/thresholding is performed in 8 or 16-bit <b>integer</b> arithmetic, because floating point requires too many cycles 
to emulate, and fixed point introduces complications with verifying that operations like multiply are correct. This places a lower bound 
on the quantization error that can occur, which leads to additional spectral leakage that can cause false positive bits in frequencies that
are not actually present.
</p>
<h3 id="tradeoff">Design Tradeoffs</h3>
<p>
We made two large design trade-offs in this project: (1) we worked primarily with a single +5V supply (except for the +12 input which was also tied
to our voltage reference), which limited the total power that we could pump into the output speaker; and (2) we worked with integer and fixed point 
arithmetic on an 8-bit microcontroller. (1) Using a higher voltage or a double-ended
supply would have increased our transmit power (and therefore our range), but the primary point of the project was to develop the software, not
to worry about the hardware. The microcontroller could conveniently produce a 0-5 V wave centered around 2.5 V, so we decided to use this to drive
the microphone directly (through a simple class A amplifier). (2) Although the Atmega was a requirement for use with the project, designing digital
signal processing algorithms for implementation using only fixed point or integer arithmetic requires sacrifices in terms of accuracy which bears
a significant cost in terms of data transmission speed and accuracy as our maximum SNR decreases due to resolution. We were also limited by the speed of the microcontroller and the frequency range supported
by our microphone and speakers, which meant that we had to sacrifice the higher transmit speeds that would have been possible with ultrasonic frequencies
rather than audible ones.
</p>
<h3 id="standards">Intellectual Property and Standards</h3>
<p>Our project should be free of intellectual property conflicts because we made a conscious effort not to learn about how commercial systems that
complete a similar task are implemented. Instead we designed all of our signal processing algorithms, the circuits, and our software based on things
that we learned from classes taken at Cornell. Our encoding scheme, OOK, is the only component of our project to have its own Wikipedia page, but
we consider it to be a technique in the public domain because of how intuitively obvious it is.
</p>
<p>The only standard to which our project conforms is RS-232, which it uses for serial communications with a computer. The RS-232 compliant hardware
is included in the Atmega644 UART and so was already prepackaged and ready for use.
</p>

<div class="bridge-section">
<h2 id="implementation">Implementation</h2>
<p><a href="#hardware">Hardware</a> | <a href="#software">Software</a>: <a href="#transmit">Transmit</a> <a href="#receive">Receive</a> <a href="#client">Client-Side</a> | <a href="#trial">Trial And Error</a></p>
<h3 id="hardware">Hardware</h3>
<p>
</p>
<h3 id="software">Software</h3>
<h4 id="transmit">Transmit</h4>
<center><div class="main-photo-largest">
	<img src="software_transmit.png" alt="" width="630"/>
	<p class="caption">Software Transmit Sequence</p>
</div></center>
<p>The software transmit system is centered around the serial Rx code in the main loop and the waveform lookup in the ISR. The serial Rx code in the main loop is simple: if a serial byte exists in the serial receive buffer, the byte is placed in one of the output channels, scheduled in a round-robin fashion. These channels each have a state-machine status associated with it. When there is no data on a channel, its status is <span class="code">IDLE</span>. Once the serial Rx code places a byte in a channel (only placing the data in an <span class="code">IDLE</span> channel), it sets the status to <span class="code">START_BIT</span>, indicating to the ISR that the channel is ready to transmit the start bit. 
</p>
<p>The main ISR runs off of timer 1 at 40 kHz (500 cycles @ 20MHz clock); timer 1 also runs a secondary ISR 20 cycles beforehand to put the CPU to sleep in order to ensure consistent timing for the main ISR. The ISR executes the waveform lookup and generation immediately after entry in order to avoid any variable-length instructions that could cause inconsistent timing.<span class="aside"><span class="title">Why frequency tables?</span><span class="body">Previously in class, we generated sinusoids through Direct Digital Synthesis (DDS) through the PWM port. For this project, we significantly simplified our output scheme by utilizing a custom sine table which we placed in the AVR's flash memory. Since there are a limited number of transmit frequencies, we can use Matlab to precompute 64 samples for every possible combination of frequencies. A lookup into flash memory, while slower than RAM access, is much faster than full DDS. The only disadvantage with this scheme is that we must recompute the table every time we wish to change the transmit frequencies or relative amplitudes.</span></span> To determine which waveform to use, the ISR examines the states of all the channels once every 64 iterations. The states indicate whether the state is <span class="code">IDLE</span>, ready to trasmit the <span class="code">START_BIT</span> (represented by 1<sub>S</sub> in the figure above), transmitting the Nth bit of the channel (starting with the MSB at 0), or trasmitting the <span class="code">STOP_BIT</span> (represented by 0<sub>S</sub> in the figure above). The ISR combines the appropriate bit of each channel into a 3-bit number with the MSB indicating the presence of 7.2 kHz, the middle bit indicating the presence of 6.0 kHz and the LSB indicating the presence of 4.8 kHz. This 3-bit number can now be used as an offset into our 2D frequency table. The first dimension of this table is the 3-bit number which indicates the combination of frequencies we wish to generate. The second dimension is a 64-element array corresponding to the 64 samples in the waveform, with each value directly correlating with a voltage range between 0V - 5V. After determining the correct waveform, the ISR increments the status of all the channels and spends the next 64 iterations outputting the appropriate samples to our DAC on PORT C. The DAC is easy to use: we simply drive the write-enable pin low, load our output onto the DAC's input pins, and drive the write-enabled pin high. The DAC takes care of the rest.
</p>
<h4 id="receive">Receive</h4>
<p>
</p>
<h3 id="trial">Trial And Error</h3>
<p>
</p>

<div class="bridge-section">
<h2 id="results">Results</h2>
<p><a href="#soft_ex">Software Execution</a> | <a href="#accuracy">Accuracy</a> | <a href="#safety">Safety Enforcement</a> | <a href="#interference">Interference and Accessibility</a></p>
<h3 id="soft_ex">Software Execution</h3>
<p></p>
<h3 id="accuracy">Accuracy</h3>
<p></p>
<h3 id="safety">Safety Enforcement</h3>
<p></p>
<h3 id="interference">Interference and Accessibility</h3>
<p>
</p>
		
<div class="bridge-section">
<h2 id="conclusion">Conclusion</h2>
<p><a href="#analysis">Analysis of Results</a> | <a href="#st_conformity">Standards Conformity</a> | <a href="#IP">IP Considerations</a> | <a href="#ethical">Ethical Considerations</a> | <a href="#legal">Legal Considerations</a></p>
<h3 id="analysis">Analysis of Results</h3>
<p></p>
<p></p>
<h3 id="st_conformity">Standards Conformity</h3>
<p></p>
<h3 id="IP">IP Considerations</h3>
<p></p>
<h3 id="ethical">Ethical Considerations</h3>
<p></p>
<h3 id="legal">Legal Considerations</h3>
<p></p>

<div class="bridge-section">
<h2 id="appendix">Appendix</h2> 
<p><a href="#code">Source Code</a> | <a href="#schematics">Schematics</a> | <a href="#parts">Parts List</a> | <a href="#task">Task Division</a> | <a href="#reference">References</a> | <a href="#acknowledgements">Acknowledgements</a></p>
<h3 id="code">Source Code</h3>
<p>The most recent version of our source code is available under the GNU GPL v3. It can be obtained from our
<a href="https://code.google.com/p/ece4760-acoustic-modem">Google Code project</a> via Subversion:</p>
<pre style="font-size: 1.5em;">svn checkout http://ece4760-acoustic-modem.googlecode.com/svn/trunk/ ece4760-acoustic-modem-read-only</pre>

<h3 id="schematics">Schematics</h3>

<h3 id="parts">Parts List</h3>
<p>Parts listed are per board. Two such boards were constructed to complete a transmit/receive pair.
<center>
<table cellspacing="0" cellpadding="0">
<tr><th>Name</th><th>Part #</th><th>Vendor</th><th>Unit Price</th><th>Quantity</th></tr>
<tr class="row1"><td>Microcontroller</td><td>Atmega644</td><td>Atmel</td><td>$8.00</td><td>1</td></tr>
<tr class="row2"><td>RS-232 Level Shifter</td><td>MAX233</td><td>Maxim IC</td><td>Free<sup>1</sup></td><td>1</td></tr>
<tr class="row1"><td>8-Bit Parallel D/A Converter</td><td>AD7801</td><td>Analog Devices</td><td>Free<sup>2</sup></td><td>1</td></tr>
<tr class="row2"><td>Single/Dual Rail-to-Rail Operational Amplifier</td><td>MAX4281/MAX4282</td><td>Maxim IC</td><td>Free<sup>2</sup></td><td>2<sup>3</sup></td></tr>
<tr class="row1"><td>+2.5 V Reference</td><td>MAX6325</td><td>Maxim IC</td><td>Free<sup>2</sup></td><td>1</td></tr>
<tr class="row2"><td>3 Watt, 8-Ohm Speaker</td><td>668-1125-ND</td><td>Digi-Key</td><td>$5.03</td><td>1</td></tr>
<tr class="row1"><td>Omnidirectional Electret Microphone</td><td>359-1029-ND</td><td>Digi-Key</td><td>$1.50</td><td>1</td></tr>
<tr class="row2"><td><a href="http://www.nbb.cornell.edu/neurobio/land/PROJECTS/Protoboard476/index.html">Custom PC Board</a></td><td>N/A</td><td>Bruce Land</td><td>$4.00</td><td>1</td></tr>
<tr class="row1"><td>Solder Board</td><td>N/A</td><td>476 Lab</td><td>$2.50</td><td>2</td></tr>
<tr class="row2"><td></td><td></td><td></td><td></td><td></td></tr>
<tr class="row1"><td></td><td></td><td></td><td></td><td></td></tr>
<tr class="row2"><td></td><td></td><td></td><td></td><td></td></tr>
<tr class="row1"><td></td><td></td><td></td><td></td><td></td></tr>
<tr class="row2"><td></td><td></td><td></td><td></td><td></td></tr>
</table>
</center>
</p>
<p>
<ul>
	<li><sup>1 - Donated by the CUAUV team, which has a stockpile of them but no longer uses the part in active designs.</sup></li>
	<li><sup>2 - Obtained via free sample from the manufacturer, no NDA required.</sup></li>
	<li><sup>3 - Three operational amplifiers in total are required. Two 4282s or a 4282 and a 4281 are sufficient to implement the circuit.</sup></li>
</ul>
</p>

<h3 id="task">Task Division</h3>
<h4>Greg Malysa</h4>
<ul>
	<li>Hardware Design</li>
	<li>Hardware Implementation</li>
	<li>DSP Algorithm Design</li>
	<li>MATLAB Implementation</li>
	<li>Software Debugging</li>
	<li>Report</li>
	<li>Website</li>
</ul> 
<h4>Arseney Romanenko</h4>
<ul>
	<li>Software Implementation</li>
	<li>DSP Algorithm Design</li>
	<li>C Conversion of MATLAB Implementation</li>
	<li>Software Debugging</li>
	<li>Report</li>
	<li>Website</li>
</ul>
<h3 id="acknowledgements">Acknowledgements</h3>
<p>
<u><i>TODO.</i></u>
</p>
<h3 id="reference">References</h3>
<h4> Datasheets </h4>
<ul>
	<li><a href="http://instruct1.cit.cornell.edu/courses/ee476/AtmelStuff/mega644full.pdf">Atmel Atmega64</a></li>
	<li><a href="AD7801.pdf">AD7801 - 8-bit Parallel DAC</a></li>
	<li><a href="MAX4174-MAX4284.pdf">MAX4281/MAX4282 - Single/Dual Rail-to-Rail Operational Amplifier</a></li>
	<li><a href="MAX6325-MAX6350.pdf">MAX6235 - +2.5 V Reference</a></li>
</ul>
<h4> Vendor Sites </h4>
<ul>
	<li><a href="http://www.atmel.com/">Atmel</a></li>
	<li><a href="http://www.maxim-ic.com/">Maxim IC</a></li>
	<li><a href="http://www.analog.com/">Analog Devices</a></li>
</ul>
<h4> Other Online Resources </h4>
<ul>
	<li><a href="http://en.wikipedia.org/wiki/Window_function">Description of several window functions and their spectral properties</a></li>
</ul>
<hr />

</body>
</html>